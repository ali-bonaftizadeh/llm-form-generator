<?xml version="1.0" encoding="UTF-8" ?>

<!--
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~       http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">

  <!-- HISTORIC PROCESS INSTANCE INSERT -->

  <insert id="insertHistoricProcessInstance" parameterType="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
      insert into ${prefix}ACT_HI_PROCINST (
        ID_,
        PROC_INST_ID_,
        BUSINESS_KEY_,
        PROC_DEF_ID_,
        START_TIME_,
        END_TIME_,
        DURATION_,
        START_USER_ID_,
        START_ACT_ID_,
        END_ACT_ID_,
        SUPER_PROCESS_INSTANCE_ID_,
        DELETE_REASON_,
        TENANT_ID_,
        NAME_
      ) values (
        #{id ,jdbcType=VARCHAR},
        #{processInstanceId, jdbcType=VARCHAR},
        #{businessKey, jdbcType=VARCHAR},
        #{processDefinitionId, jdbcType=VARCHAR},
        #{startTime, jdbcType=TIMESTAMP},
        #{endTime, jdbcType=TIMESTAMP},
        #{durationInMillis ,jdbcType=BIGINT},
        #{startUserId, jdbcType=VARCHAR},
        #{startActivityId, jdbcType=VARCHAR},
        #{endActivityId, jdbcType=VARCHAR},
        #{superProcessInstanceId, jdbcType=VARCHAR},
        #{deleteReason, jdbcType=VARCHAR},
        #{tenantId, jdbcType=VARCHAR},
        #{name, jdbcType=VARCHAR}
      )
  </insert>

  <insert id="bulkInsertHistoricProcessInstance" parameterType="java.util.List">
      insert into ${prefix}ACT_HI_PROCINST (
        ID_,
        PROC_INST_ID_,
        BUSINESS_KEY_,
        PROC_DEF_ID_,
        START_TIME_,
        END_TIME_,
        DURATION_,
        START_USER_ID_,
        START_ACT_ID_,
        END_ACT_ID_,
        SUPER_PROCESS_INSTANCE_ID_,
        DELETE_REASON_,
        TENANT_ID_,
        NAME_
      ) values
        <foreach collection="list" item="historicProcessInstance" index="index" separator=",">
          (#{historicProcessInstance.id ,jdbcType=VARCHAR},
           #{historicProcessInstance.processInstanceId, jdbcType=VARCHAR},
           #{historicProcessInstance.businessKey, jdbcType=VARCHAR},
           #{historicProcessInstance.processDefinitionId, jdbcType=VARCHAR},
           #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.durationInMillis ,jdbcType=BIGINT},
           #{historicProcessInstance.startUserId, jdbcType=VARCHAR},
           #{historicProcessInstance.startActivityId, jdbcType=VARCHAR},
           #{historicProcessInstance.endActivityId, jdbcType=VARCHAR},
           #{historicProcessInstance.superProcessInstanceId, jdbcType=VARCHAR},
           #{historicProcessInstance.deleteReason, jdbcType=VARCHAR},
           #{historicProcessInstance.tenantId, jdbcType=VARCHAR},
           #{historicProcessInstance.name, jdbcType=VARCHAR})
         </foreach>
  </insert>

  <insert id="bulkInsertHistoricProcessInstance" databaseId="oracle" parameterType="java.util.List">
      INSERT ALL
        <foreach collection="list" item="historicProcessInstance" index="index">
          INTO ${prefix}ACT_HI_PROCINST (
            ID_,
            PROC_INST_ID_,
            BUSINESS_KEY_,
            PROC_DEF_ID_,
            START_TIME_,
            END_TIME_,
            DURATION_,
            START_USER_ID_,
            START_ACT_ID_,
            END_ACT_ID_,
            SUPER_PROCESS_INSTANCE_ID_,
            DELETE_REASON_,
            TENANT_ID_,
            NAME_
          ) VALUES
              (#{historicProcessInstance.id ,jdbcType=VARCHAR},
               #{historicProcessInstance.processInstanceId, jdbcType=VARCHAR},
               #{historicProcessInstance.businessKey, jdbcType=VARCHAR},
               #{historicProcessInstance.processDefinitionId, jdbcType=VARCHAR},
               #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.durationInMillis ,jdbcType=BIGINT},
               #{historicProcessInstance.startUserId, jdbcType=VARCHAR},
               #{historicProcessInstance.startActivityId, jdbcType=VARCHAR},
               #{historicProcessInstance.endActivityId, jdbcType=VARCHAR},
               #{historicProcessInstance.superProcessInstanceId, jdbcType=VARCHAR},
               #{historicProcessInstance.deleteReason, jdbcType=VARCHAR},
               #{historicProcessInstance.tenantId, jdbcType=VARCHAR},
               #{historicProcessInstance.name, jdbcType=VARCHAR})
       </foreach>
    SELECT * FROM dual
  </insert>

  <!-- HISTORIC PROCESS INSTANCE UPDATE -->

  <update id="updateHistoricProcessInstance" parameterType="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    update ${prefix}ACT_HI_PROCINST set
      PROC_DEF_ID_ = #{processDefinitionId, jdbcType=VARCHAR},
      BUSINESS_KEY_ = #{businessKey, jdbcType=VARCHAR},
      START_TIME_ = #{startTime, jdbcType=TIMESTAMP},
      END_TIME_ = #{endTime, jdbcType=TIMESTAMP},
      DURATION_ = #{durationInMillis ,jdbcType=BIGINT},
      END_ACT_ID_ = #{endActivityId, jdbcType=VARCHAR},
      DELETE_REASON_ = #{deleteReason, jdbcType=VARCHAR},
      NAME_ = #{name, jdbcType=VARCHAR}
    where ID_ = #{id}
  </update>

  <!-- HISTORIC PROCESS INSTANCE DELETE -->

  <delete id="deleteHistoricProcessInstance">
    delete from ${prefix}ACT_HI_PROCINST where PROC_INST_ID_ = #{processInstanceId}
  </delete>

  <delete id="bulkDeleteHistoricProcessInstance" parameterType="java.util.Collection">
    delete from ${prefix}ACT_HI_PROCINST where
     <foreach item="procInst" collection="list" index="index" separator=" or ">
        ID_ = #{procInst.id, jdbcType=VARCHAR}
    </foreach>
  </delete>

  <!-- HISTORIC PROCESS INSTANCE RESULT MAP -->

  <resultMap id="historicProcessInstanceResultMap" type="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    <id property="id" column="ID_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="VARCHAR" />
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="VARCHAR"/>
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="PROC_DEF_NAME_" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="PROC_DEF_KEY_" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="PROC_DEF_VERSION_" jdbcType="INTEGER" />
    <result property="deploymentId" column="DEPLOYMENT_ID_" jdbcType="VARCHAR" />
    <result property="startTime" column="START_TIME_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="END_TIME_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="DURATION_" jdbcType="BIGINT" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="VARCHAR" />
    <result property="startActivityId" column="START_ACT_ID_" jdbcType="VARCHAR" />
    <result property="endActivityId" column="END_ACT_ID_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="VARCHAR" />
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="VARCHAR" />
    <result property="tenantId" column="TENANT_ID_" jdbcType="VARCHAR" />
    <result property="name" column="NAME_" jdbcType="VARCHAR" />
  </resultMap>

  <resultMap id="historicProcessInstanceAndVariablesResultMap" type="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    <id property="id" column="ID_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="VARCHAR" />
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="VARCHAR"/>
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="PROC_DEF_NAME_" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="PROC_DEF_KEY_" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="PROC_DEF_VERSION_" jdbcType="INTEGER" />
    <result property="deploymentId" column="DEPLOYMENT_ID_" jdbcType="VARCHAR" />
    <result property="startTime" column="START_TIME_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="END_TIME_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="DURATION_" jdbcType="BIGINT" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="VARCHAR" />
    <result property="startActivityId" column="START_ACT_ID_" jdbcType="VARCHAR" />
    <result property="endActivityId" column="END_ACT_ID_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="VARCHAR" />
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="VARCHAR" />
    <result property="tenantId" column="TENANT_ID_" jdbcType="VARCHAR" />
    <result property="name" column="NAME_" jdbcType="VARCHAR" />
    <collection property="queryVariables" column="EXECUTION_ID_" javaType="ArrayList" ofType="org.activiti.engine.impl.persistence.entity.HistoricVariableInstanceEntityImpl">
      <id property="id" column="VAR_ID_"/>
      <result property="name" column="VAR_NAME_" javaType="String" jdbcType="VARCHAR" />
      <result property="variableType" column="VAR_TYPE_" javaType="org.activiti.engine.impl.variable.VariableType" jdbcType="VARCHAR" />
      <result property="revision" column="VAR_REV_" jdbcType="INTEGER" />
      <result property="processInstanceId" column="VAR_PROC_INST_ID_" jdbcType="VARCHAR" />
      <result property="executionId" column="VAR_EXECUTION_ID_" jdbcType="VARCHAR" />
      <result property="taskId" column="VAR_TASK_ID_" jdbcType="VARCHAR" />
      <result property="byteArrayRef" column="VAR_BYTEARRAY_ID_" typeHandler="ByteArrayRefTypeHandler"/>
      <result property="doubleValue" column="VAR_DOUBLE_" jdbcType="DOUBLE" />
      <result property="textValue" column="VAR_TEXT_" jdbcType="VARCHAR" />
      <result property="textValue2" column="VAR_TEXT2_" jdbcType="VARCHAR" />
      <result property="longValue" column="VAR_LONG_" jdbcType="BIGINT" />
    </collection>
  </resultMap>

  <!-- HISTORIC PROCESS INSTANCE SELECT -->

  <select id="selectHistoricProcessInstance" resultMap="historicProcessInstanceResultMap">
    select * from ${prefix}ACT_HI_PROCINST where PROC_INST_ID_ = #{processInstanceId, jdbcType=VARCHAR}
  </select>

  <select id="selectHistoricProcessInstanceIdsByProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultType="string">
    select ID_
    from ${prefix}ACT_HI_PROCINST
    where PROC_DEF_ID_ = #{parameter}
  </select>

    <select id="selectHistoricProcessInstanceIdsBySuperProcessInstanceId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="historicProcessInstanceResultMap">
    select *
    from ${prefix}ACT_HI_PROCINST
    where SUPER_PROCESS_INSTANCE_ID_ = #{parameter}
  </select>


  <select id="selectHistoricProcessInstancesByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceResultMap">
    <include refid="selectHistoricProcessInstancesByQueryCriteria">
      <property name="isCount" value="false"/>
    </include>
  </select>

  <select id="selectHistoricProcessInstanceCountByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultType="long">
    <include refid="selectHistoricProcessInstancesByQueryCriteria">
      <property name="isCount" value="true"/>
    </include>
  </select>

  <select id="selectHistoricProcessInstancesWithVariablesByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceAndVariablesResultMap">
    <include refid="selectHistoricProcessInstancesWithVariablesByQueryCriteria">
      <property name="isCount" value="false"/>
    </include>
  </select>

  <sql id="commonSelectHistoricProcessInstancesByQueryCriteriaSql">
    <!-- joins -->

    <!-- join: process variables -->
    <if test="includeProcessVariables">
      left join ${prefix}ACT_HI_VARINST VAR
      <!-- TODO: this "foreign key" is different from the other ACT_HI_VARINST use-case -->
      ON RES.PROC_INST_ID_ = VAR.EXECUTION_ID_
      and VAR.TASK_ID_ is null
    </if>
    <!-- join: deployment/process-definitions -->
    <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF"/></include>
    <if test="deploymentId != null">
      AND DEF.DEPLOYMENT_ID_ = #{deploymentId}
    </if>
    <if test="deploymentIds != null &amp;&amp; deploymentIds.isEmpty() == false">
      AND DEF.DEPLOYMENT_ID_ IN
      <foreach item="item" index="index" collection="deploymentIds" open="(" separator="," close=")">
        #{item}
      </foreach>
    </if>
    <if test="processDefinitionName != null">
      and DEF.NAME_ = #{processDefinitionName}
    </if>
    <!-- join: jobs with exception -->
    <if test="withException">
      <include refid="join_ACT_RU_TIMER_JOB"><property name="tableAlias" value="JOB"/></include>
      and (
      JOB.EXCEPTION_MSG_ is not null
      or JOB.EXCEPTION_STACK_ID_ is not null
      )
    </if>
    <!-- join: involved user -->
    <if test="involvedUser != null">
      <include refid="join_ACT_HI_IDENTITYLINK"><property name="tableAlias" value="link_user"/></include>
      and link_user.USER_ID_ = #{involvedUser}
    </if>
    <!-- join: involved groups -->
    <if test="involvedGroups != null &amp;&amp; involvedGroups.size() &gt; 0">
      <include refid="join_ACT_HI_IDENTITYLINK"><property name="tableAlias" value="link_groups"/></include>
      and (
      link_groups.TYPE_ = 'participant'
      and link_groups.GROUP_ID_ in <include refid="collection"><property name="collection" value="involvedGroups"/></include>
      )
    </if>
    <!-- join: variables -->
    <if test="queryVariableValues != null &amp;&amp; queryVariableValues.size() &gt; 0">
      <include refid="leftJoinVariables_processes">
        <property name="externalTableAlias" value="A"/>
        <property name="collection" value="queryVariableValues"/>
      </include>
    </if>
    <!-- join: orQueries -->
    <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
      <if test="orQueryObject.deploymentId != null">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        and DEF_OR${orIndex}.DEPLOYMENT_ID_ = #{orQueryObject.deploymentId}
      </if>
      <if test="orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentsIds.isEmpty() == false">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        and DEF_OR${orIndex}.DEPLOYMENT_ID_ IN
        <foreach item="deployment" index="index" collection="#{orQueryObject.deploymentId}" open="(" separator="," close=")">
          #{deployment}
        </foreach>
      </if>
      <if test="orQueryObject.involvedUser != null">
        <include refid="join_ACT_HI_IDENTITYLINK"><property name="tableAlias" value="link_user_or${orIndex}"/></include>
        and link_user_or${orIndex}.USER_ID_ = #{orQueryObject.involvedUser}
      </if>
      <if test="orQueryObject.involvedGroups != null &amp;&amp; orQueryObject.involvedGroups.size() &gt; 0">
        <include refid="join_ACT_HI_IDENTITYLINK"><property name="tableAlias" value="link_groups_or${orIndex}"/></include>
        and (
        link_groups_or${orIndex}.TYPE_ = 'participant'
        and link_groups_or${orIndex}.GROUP_ID_ in
        <foreach item="group" index="index" collection="orQueryObject.involvedGroups" open="(" separator="," close=")">
          #{group}
        </foreach>
        )
      </if>
      <if test="orQueryObject.processDefinitionName != null">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        and DEF_OR${orIndex}.NAME_ = #{orQueryObject.processDefinitionName}
      </if>
      <if test="orQueryObject.processDefinitionKey != null || (orQueryObject.processDefinitionKeyIn != null &amp;&amp; orQueryObject.processDefinitionKeyIn.size() &gt; 0)">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        <!-- TODO: don't understand why this doesn't have any AND statement inside -->
      </if>
      <if test="orQueryObject.processDefinitionCategory != null ">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        AND DEF_OR${orIndex}.CATEGORY_ = #{orQueryObject.processDefinitionCategory}
      </if>
      <if test="orQueryObject.processDefinitionVersion != null">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        and DEF_OR${orIndex}.VERSION_ = #{orQueryObject.processDefinitionVersion}
      </if>
      <if test="orQueryObject.processKeyNotIn != null &amp;&amp; orQueryObject.processKeyNotIn.size() &gt; 0">
        <include refid="join_ACT_RE_PROCDEF"><property name="tableAlias" value="DEF_OR${orIndex}"/></include>
        <!-- TODO: don't understand why this doesn't have any AND statement inside -->
      </if>
      <if test="orQueryObject.queryVariableValues != null &amp;&amp; orQueryObject.queryVariableValues.size() &gt; 0">
        <include refid="leftJoinVariables_processes">
          <property name="externalTableAlias" value="A_OR${orIndex}"/>
          <property name="collection" value="orQueryObject.queryVariableValues"/>
        </include>
      </if>
      <if test="orQueryObject.withException">
        <include refid="join_ACT_RU_TIMER_JOB"><property name="tableAlias" value="JOB_OR${orIndex}"/></include>
        and (
        JOB_OR${orIndex}.EXCEPTION_MSG_ is not null
        or JOB_OR${orIndex}.EXCEPTION_STACK_ID_ is not null
        )
      </if>
    </foreach>

    <!-- where -->
    <where>
      <if test="processInstanceId != null">
        and RES.PROC_INST_ID_ = #{processInstanceId}
      </if>
      <if test="processInstanceIds != null and !processInstanceIds.isEmpty()">
        and RES.PROC_INST_ID_ in <include refid="collection"><property name="collection" value="processInstanceIds"/></include>
      </if>
      <if test="processDefinitionId != null">
        and RES.PROC_DEF_ID_ = #{processDefinitionId}
      </if>
      <if test="processDefinitionKey != null">
        and DEF.KEY_ = #{processDefinitionKey}
      </if>
      <if test="processDefinitionKeyIn != null &amp;&amp; processDefinitionKeyIn.size() &gt; 0">
        and DEF.KEY_ IN <include refid="collection"><property name="collection" value="processDefinitionKeyIn"/></include>
      </if>
      <if test="processDefinitionVersion != null">
        and DEF.VERSION_ = #{processDefinitionVersion}
      </if>
      <if test="processDefinitionCategory != null">
        and DEF.CATEGORY_ = #{processDefinitionCategory}
      </if>
      <if test="processDefinitionName != null">
        and DEF.ID_ is not null
      </if>
      <if test="businessKey != null">
        and RES.BUSINESS_KEY_ = #{businessKey}
      </if>
      <if test="deploymentId != null">
        AND DEF.ID_ is not null
      </if>
      <if test="deploymentIds != null &amp;&amp; deploymentIds.isEmpty()==false">
        AND DEF.ID_ is not null
      </if>
      <if test="startedBefore != null">
        and RES.START_TIME_ &lt;= #{startedBefore}
      </if>
      <if test="startedAfter != null">
        and RES.START_TIME_ &gt;= #{startedAfter}
      </if>
      <if test="finishedBefore != null">
        and RES.END_TIME_ &lt;= #{finishedBefore}
      </if>
      <if test="finishedAfter != null">
        and RES.END_TIME_ &gt;= #{finishedAfter}
      </if>
      <if test="processKeyNotIn != null &amp;&amp; processKeyNotIn.size() &gt; 0">
        <foreach collection="processKeyNotIn" index="index" item="procDefKey">
          and DEF.KEY_ not like #{procDefKey}${wildcardEscapeClause}
        </foreach>
      </if>
      <if test="unfinished">
        and RES.END_TIME_ IS NULL
      </if>
      <if test="finished">
        and RES.END_TIME_ is not NULL
      </if>
      <if test="notDeleted">
        and RES.DELETE_REASON_ IS NULL
      </if>
      <if test="deleted">
        and RES.DELETE_REASON_ IS NOT NULL
      </if>
      <if test="involvedUser != null">
        and link_user.ID_ is not null
      </if>
      <if test="involvedGroups != null &amp;&amp; involvedGroups.size() &gt; 0">
        and link_groups.ID_ is not null
      </if>
      <if test="startedBy != null">
        and RES.START_USER_ID_ = #{startedBy}
      </if>
      <if test="superProcessInstanceId != null">
        and RES.SUPER_PROCESS_INSTANCE_ID_ = #{superProcessInstanceId}
      </if>
      <if test="excludeSubprocesses">
        and RES.SUPER_PROCESS_INSTANCE_ID_ is null
      </if>
      <if test="tenantId != null">
        and RES.TENANT_ID_ = #{tenantId}
      </if>
      <if test="tenantIdLike != null">
        and RES.TENANT_ID_ like #{tenantIdLike}${wildcardEscapeClause}
      </if>
      <if test="withoutTenantId">
        and (RES.TENANT_ID_ = '' or RES.TENANT_ID_ is null)
      </if>
       <if test="name != null">
        and RES.NAME_ = #{name}
      </if>
      <if test="nameLike != null">
        and RES.NAME_ like #{nameLike}${wildcardEscapeClause}
      </if>
        <if test="nameLikeIgnoreCase != null">
        and lower(RES.NAME_) like #{nameLikeIgnoreCase}${wildcardEscapeClause}
      </if>
      <!-- variable values -->
      <if test="queryVariableValues != null &amp;&amp; queryVariableValues.size() &gt; 0">
        <foreach index="varIndex" item="varObject" collection="queryVariableValues">
          and A_${varIndex}.ID_ is not null
        </foreach>
      </if>
      <!-- orQueries -->
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        and
        <trim prefix="(" prefixOverrides="OR" suffix=")">
          <if test="orQueryObject.processInstanceId != null">
            or RES.PROC_INST_ID_ = #{orQueryObject.processInstanceId}
          </if>
          <if test="orQueryObject.processInstanceIds != null and !orQueryObject.processInstanceIds.isEmpty()">
            or RES.PROC_INST_ID_ in
            <foreach item="item" index="index" collection="orQueryObject.processInstanceIds" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionId != null">
            or RES.PROC_DEF_ID_ = #{orQueryObject.processDefinitionId}
          </if>
          <if test="orQueryObject.processDefinitionKey != null">
            or DEF_OR${orIndex}.KEY_ = #{orQueryObject.processDefinitionKey}
          </if>
          <if test="orQueryObject.processDefinitionKeyIn != null &amp;&amp; orQueryObject.processDefinitionKeyIn.size() &gt; 0">
            or DEF_OR${orIndex}.KEY_ IN <include refid="collection"><property name="collection" value="orQueryObject.processDefinitionKeyIn"/></include>
          </if>
          <if test="orQueryObject.processDefinitionVersion != null">
            or DEF_OR${orIndex}.ID_ is not null
          </if>
          <if test="orQueryObject.processDefinitionCategory != null">
            or DEF_OR${orIndex}.ID_ is not null
          </if>
          <if test="orQueryObject.processDefinitionName != null">
            or DEF_OR${orIndex}.ID_ is not null
          </if>
          <if test="orQueryObject.businessKey != null">
            or RES.BUSINESS_KEY_ = #{orQueryObject.businessKey}
          </if>
          <if test="orQueryObject.deploymentId != null">
            OR DEF_OR${orIndex}.ID_ IS NOT null
          </if>
          <if test="orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentIds.size() &gt; 0">
            or DEF_OR${orIndex}.ID_ in
            <foreach item="item" index="index" collection="orQueryObject.deploymentIds" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.startedBefore != null">
            or RES.START_TIME_ &lt;= #{orQueryObject.startedBefore}
          </if>
          <if test="orQueryObject.startedAfter != null">
            or RES.START_TIME_ &gt;= #{orQueryObject.startedAfter}
          </if>
          <if test="orQueryObject.finishedBefore != null">
            or RES.END_TIME_ &lt;= #{orQueryObject.finishedBefore}
          </if>
          <if test="orQueryObject.finishedAfter != null">
            or RES.END_TIME_ &gt;= #{orQueryObject.finishedAfter}
          </if>
          <if test="orQueryObject.processKeyNotIn != null &amp;&amp; orQueryObject.processKeyNotIn.size() &gt; 0">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <foreach collection="orQueryObject.processKeyNotIn" index="index" item="procDefKey">
                and DEF_OR${orIndex}.KEY_ not like #{procDefKey}${wildcardEscapeClause}
              </foreach>
            </trim>
          </if>
          <if test="orQueryObject.unfinished">
            or RES.END_TIME_ IS NULL
          </if>
          <if test="orQueryObject.finished">
            or RES.END_TIME_ is not NULL
          </if>
          <if test="orQueryObject.notDeleted">
            or RES.DELETE_REASON_ IS NULL
          </if>
          <if test="orQueryObject.deleted">
            or RES.DELETE_REASON_ IS NOT NULL
          </if>
          <if test="orQueryObject.involvedUser != null">
            or link_user_or${orIndex}.ID_ is not null
          </if>
          <if test="orQueryObject.involvedGroups != null &amp;&amp; orQueryObject.involvedGroups.size() &gt; 0">
            or link_groups_or${orIndex}.ID_ is not null
          </if>
          <if test="orQueryObject.startedBy != null">
            or RES.START_USER_ID_ = #{orQueryObject.startedBy}
          </if>
          <if test="orQueryObject.superProcessInstanceId != null">
            or RES.SUPER_PROCESS_INSTANCE_ID_ = #{orQueryObject.superProcessInstanceId}
          </if>
          <if test="orQueryObject.excludeSubprocesses">
            or RES.SUPER_PROCESS_INSTANCE_ID_ is null
          </if>
          <if test="orQueryObject.tenantId != null">
            or RES.TENANT_ID_ = #{orQueryObject.tenantId}
          </if>
          <if test="orQueryObject.tenantIdLike != null">
            or RES.TENANT_ID_ like #{orQueryObject.tenantIdLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.withoutTenantId">
            or (RES.TENANT_ID_ = '' or RES.TENANT_ID_ is null)
          </if>
           <if test="orQueryObject.name != null">
            or RES.NAME_ = #{orQueryObject.name}
          </if>
          <if test="orQueryObject.nameLike != null">
            or RES.NAME_ like #{orQueryObject.nameLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.nameLikeIgnoreCase != null">
            or lower(RES.NAME_) like #{orQueryObject.nameLikeIgnoreCase}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.withException">
            or JOB_OR${orIndex}.ID_ is not null
          </if>
          <!-- variables values -->
          <if test="orQueryObject.queryVariableValues != null &amp;&amp; orQueryObject.queryVariableValues.size() &gt; 0">
            <foreach index="varIndex" item="varObject" collection="orQueryObject.queryVariableValues">
              or A_OR${orIndex}_${varIndex}.ID_ is not null
            </foreach>
          </if>
        </trim>
      </foreach>
      <if test="withException">
        and JOB.ID_ is not null
      </if>
    </where>
  </sql>

  <sql id="executionVariableOperator">
    <choose>
      <when test="varObject.operator.equals('EQUALS')">=</when>
      <when test="varObject.operator.equals('EQUALS_IGNORE_CASE')">=</when>
      <when test="varObject.operator.equals('NOT_EQUALS')">&lt;&gt;</when>
      <when test="varObject.operator.equals('NOT_EQUALS_IGNORE_CASE')">&lt;&gt;</when>
      <when test="varObject.operator.equals('GREATER_THAN')">&gt;</when>
      <when test="varObject.operator.equals('GREATER_THAN_OR_EQUAL')">&gt;=</when>
      <when test="varObject.operator.equals('LESS_THAN')">&lt;</when>
      <when test="varObject.operator.equals('LESS_THAN_OR_EQUAL')">&lt;=</when>
    </choose>
  </sql>

   <select id="selectHistoricProcessInstanceByNativeQuery" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
   	<include refid="org.activiti.engine.db.common.selectByNativeQuery"/>
  </select>

  <select id="selectHistoricProcessInstanceCountByNativeQuery" parameterType="java.util.Map" resultType="long">
    ${sql}
  </select>

  <!-- how to join tables -->
  <sql id="join_ACT_RE_PROCDEF">
    left join ${prefix}ACT_RE_PROCDEF ${tableAlias}
    on RES.PROC_DEF_ID_ = ${tableAlias}.ID_
  </sql>
  <sql id="join_ACT_HI_IDENTITYLINK">
    left join ${prefix}ACT_HI_IDENTITYLINK ${tableAlias}
    on RES.ID_ = ${tableAlias}.PROC_INST_ID_
  </sql>
  <sql id="join_ACT_RU_TIMER_JOB">
    left join ${prefix}ACT_RU_TIMER_JOB ${tableAlias}
    on RES.PROC_INST_ID_ = ${tableAlias}.PROCESS_INSTANCE_ID_
  </sql>
  <sql id="collection">
    <foreach item="item" index="index" collection="${collection}" open="(" separator="," close=")">
      #{item}
    </foreach>
  </sql>

  <sql id="leftJoinVariables_processes">
    <foreach index="varIndex" item="varObject" collection="${collection}">
      left join ${prefix}ACT_HI_VARINST ${externalTableAlias}_${varIndex}
      <!-- TODO: this "foreign key" is different from the other ACT_HI_VARINST use-case -->
      on RES.PROC_INST_ID_ = ${externalTableAlias}_${varIndex}.PROC_INST_ID_
      <if test="varObject.name != null">
        and ${externalTableAlias}_${varIndex}.NAME_ = #{varObject.name}
      </if>
      <if test="!varObject.type.equals('null')">
        <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
        and ${externalTableAlias}_${varIndex}.VAR_TYPE_ = #{varObject.type}
      </if>
      <if test="varObject.textValue != null &amp;&amp; varObject.longValue == null &amp;&amp; varObject.doubleValue == null">
        <choose>
          <when test="varObject.operator.equals('EQUALS_IGNORE_CASE') || varObject.operator.equals('NOT_EQUALS_IGNORE_CASE') || varObject.operator.equals('LIKE_IGNORE_CASE')">
            and lower(${externalTableAlias}_${varIndex}.TEXT_)
          </when>
          <otherwise>
            and ${externalTableAlias}_${varIndex}.TEXT_
          </otherwise>
        </choose>
        <choose>
          <when test="varObject.operator.equals('LIKE') || varObject.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
          <otherwise><include refid="executionVariableOperator" /></otherwise>
        </choose>
        #{varObject.textValue}
        <choose>
          <when test="varObject.operator.equals('LIKE') || varObject.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
        </choose>
      </if>
      <if test="varObject.textValue2 != null">
        and ${externalTableAlias}_${varIndex}.TEXT2_
        <choose>
          <when test="varObject.operator.equals('LIKE')">LIKE</when>
          <otherwise><include refid="executionVariableOperator" /></otherwise>
        </choose>
        #{varObject.textValue2}
        <choose>
          <when test="varObject.operator.equals('LIKE')">${wildcardEscapeClause}</when>
        </choose>
      </if>
      <if test="varObject.longValue != null">
        and ${externalTableAlias}_${varIndex}.LONG_
        <include refid="executionVariableOperator" />
        #{varObject.longValue}
      </if>
      <if test="varObject.doubleValue != null">
        and ${externalTableAlias}_${varIndex}.DOUBLE_
        <include refid="executionVariableOperator" />
        #{varObject.doubleValue}
      </if>
      <!-- Null variable type -->
      <if test="varObject.textValue == null &amp;&amp; varObject.textValue2 == null &amp;&amp; varObject.longValue == null &amp;&amp; varObject.doubleValue == null">
        <choose>
          <when test="varObject.operator.equals('NOT_EQUALS')">
            and (
            ${externalTableAlias}_${varIndex}.TEXT_ is not null
            or ${externalTableAlias}_${varIndex}.TEXT2_ is not null
            or ${externalTableAlias}_${varIndex}.LONG_ is not null
            or ${externalTableAlias}_${varIndex}.DOUBLE_ is not null
            or ${externalTableAlias}_${varIndex}.BYTEARRAY_ID_ is not null
            )
          </when>
          <otherwise>
            and (
            ${externalTableAlias}_${varIndex}.TEXT_ is null
            and ${externalTableAlias}_${varIndex}.TEXT2_ is null
            and ${externalTableAlias}_${varIndex}.LONG_ is null
            and ${externalTableAlias}_${varIndex}.DOUBLE_ is null
            and ${externalTableAlias}_${varIndex}.BYTEARRAY_ID_ is null
            )
          </otherwise>
        </choose>
      </if>
    </foreach>
  </sql>

  <sql id="orderBy">
    <if test="'${v3_limitAfter}' != null">
      ${v3_limitAfter}
      <if test="${isCount} != true">
        ORDER BY rnk
      </if>
    </if>
  </sql>

  <sql id="selectHistoricProcessInstancesByQueryCriteria">
    <!-- constants -->
    <bind name="columns" value="'RES.*, DEF.KEY_ as PROC_DEF_KEY_, DEF.NAME_ as PROC_DEF_NAME_, DEF.VERSION_ as PROC_DEF_VERSION_, DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_'"/>

    <!-- distinct management -->
    <bind name="distinctMode" value="''"/>
    <if test="withException">
      <bind name="distinctMode" value="'distinct'"/>
    </if>
    <if test="involvedGroups != null &amp;&amp; involvedGroups.size() &gt; 0">
      <bind name="distinctMode" value="'distinct'"/>
    </if>
    <if test="orQueryObjects != null &amp;&amp; orQueryObjects.size() &gt; 0">
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        <if test="orQueryObject.withException">
          <bind name="distinctMode" value="'distinct'"/>
        </if>
        <if test="orQueryObject.involvedGroups != null &amp;&amp; orQueryObject.involvedGroups.size() &gt; 0">
          <bind name="distinctMode" value="'distinct'"/>
        </if>
        <if test="orQueryObject.queryVariableValues != null &amp;&amp; orQueryObject.queryVariableValues.size() &gt; 0">
          <bind name="distinctMode" value="'distinct'"/>
        </if>
      </foreach>
    </if>
    <!-- because we can have the same variable on the same process-instance but on different executions, we need to have distinct -->
    <if test="queryVariableValues != null &amp;&amp; queryVariableValues.size() &gt; 0">
      <bind name="distinctMode" value="'distinct'"/>
    </if>
    <if test="includeProcessVariables">
      <bind name="distinctMode" value="'distinct'"/>
    </if>

    <!-- process variables management -->
    <bind name="PROCESS_VARIABLES_COLUMNS" value="',VAR.ID_ as VAR_ID_,
    VAR.NAME_ as VAR_NAME_,
    VAR.VAR_TYPE_ as VAR_TYPE_,
    VAR.REV_ as VAR_REV_,
    VAR.PROC_INST_ID_ as VAR_PROC_INST_ID_,
    VAR.EXECUTION_ID_ as VAR_EXECUTION_ID_,
    VAR.TASK_ID_ as VAR_TASK_ID_,
    VAR.BYTEARRAY_ID_ as VAR_BYTEARRAY_ID_,
    VAR.DOUBLE_ as VAR_DOUBLE_,
    VAR.TEXT_ as VAR_TEXT_,
    VAR.TEXT2_ as VAR_TEXT2_,
    VAR.LAST_UPDATED_TIME_ as VAR_LAST_UPDATED_TIME_,
    VAR.LONG_ as VAR_LONG_'"/>
    <choose>
      <when test="includeProcessVariables">
        <bind name="processVariablesColumns" value="PROCESS_VARIABLES_COLUMNS"/>
      </when>
      <otherwise>
        <bind name="processVariablesColumns" value="''"/>
      </otherwise>
    </choose>

    <choose>
      <!-- TODO: problem when dealing with returning variables
           Unit-test: HistoricProcessInstanceAndVariablesQueryTest.testOrQueryByprocessDefinition()
        - workflow
          - sql query joins process-instances with variables (in the example, it returns 10 records)
          - after sql-query, there's a java code that joins variables into process-instances (in the example, ends with 6 results)
        - problem
          - count only act on the DB layer, therefore it counts 10 records instead of 6
        - solution
          - added a use-case where we count distincts ids
        - why this is not a good solution?
          - the processing of list is splited between db and java layer
          - the processing of count is just on the db layer
          - the processing should be done at the same layers
      -->
      <!-- TODO: original solution, doesn't work because it counts all rows -->
      <!--
            <when test="${isCount}">
            <bind name="columnsCount" value="'COUNT(ID_)'"/>
            </when>
      -->
      <!-- WORKAROUND: consider counting distinct IDS -->
      <when test="${isCount}">
        <choose>
          <when test="distinctMode == 'distinct'">
            <bind name="columnsCount" value="'COUNT(DISTINCT uniqueId)'"/>
          </when>
          <otherwise>
            <bind name="columnsCount" value="'COUNT(ID_)'"/>
          </otherwise>
        </choose>
      </when>
      <otherwise>
        <bind name="columnsCount" value="'*'"/>
      </otherwise>
    </choose>

    <choose>
      <!-- distinct -->
      <when test="distinctMode == 'distinct'">
        SELECT ${columnsCount}
        FROM (
        SELECT RES.*, ROW_NUMBER() OVER (ORDER BY ${orderByColumns}) AS rnk
        FROM (
        SELECT distinct RES.ID_ as uniqueId, ${columns} ${processVariablesColumns}
        from ${prefix}ACT_HI_PROCINST RES
        <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
        <include refid="orderBy"/>
      </when>
      <!-- no distinct -->
      <otherwise>
        SELECT ${columnsCount}
        FROM (
        SELECT RES.*, ROW_NUMBER() OVER (ORDER BY ${orderByColumns}) as rnk
        FROM (
        SELECT ${columns} ${processVariablesColumns}
        from ${prefix}ACT_HI_PROCINST RES
        <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
        <include refid="orderBy"/>
      </otherwise>
    </choose>
  </sql>

  <sql id="selectHistoricProcessInstancesWithVariablesByQueryCriteria">
    <include refid="selectHistoricProcessInstancesByQueryCriteria">
      <property name="isCount" value="false"/>
    </include>
  </sql>

</mapper>
